use anyhow::{Context, Result};
use colored::Colorize;
use std::collections::HashMap;
use std::path::Path;
use walkdir::WalkDir;

use super::adopt_utils::{classify_file, detect_frameworks, detect_language, ensure_process_dir, IGNORE_DIRS};

const MAX_FILES: usize = 500;

pub fn execute() -> Result<()> {
    println!("{}", "Adopt: Scan Structure — Analyzing project layout".bold().blue());

    ensure_process_dir()?;

    let mut extensions: HashMap<String, usize> = HashMap::new();
    let mut files: Vec<(String, String)> = Vec::new();
    let mut root_files: Vec<String> = Vec::new();

    let walker = WalkDir::new(".").into_iter().filter_entry(|e| {
        let name = e.file_name().to_string_lossy();
        !IGNORE_DIRS.contains(&name.as_ref())
    });

    for entry in walker.filter_map(|e| e.ok()) {
        let path = entry.path();

        // Collect root-level file names
        if path.parent() == Some(Path::new(".")) && path.is_file() {
            if let Some(name) = path.file_name() {
                root_files.push(name.to_string_lossy().to_string());
            }
        }

        if !path.is_file() {
            continue;
        }

        // Count extensions
        if let Some(ext) = path.extension() {
            let ext_str = ext.to_string_lossy().to_lowercase();
            *extensions.entry(ext_str).or_default() += 1;
        }

        // Normalize path (strip leading ./)
        let rel = path
            .strip_prefix("./")
            .unwrap_or(path)
            .to_string_lossy()
            .to_string();

        if rel == "." {
            continue;
        }

        let category = classify_file(&rel);
        files.push((rel, category.to_string()));

        if files.len() >= MAX_FILES {
            println!(
                "{} File list capped at {} entries",
                "⚠".yellow(),
                MAX_FILES
            );
            break;
        }
    }

    let language = detect_language(&extensions);
    let frameworks = detect_frameworks(&root_files);

    // Build YAML output
    let mut yaml = String::new();
    yaml.push_str("# skeleton.yaml — generated by adopt scan-structure\n");
    yaml.push_str("metadata:\n");
    yaml.push_str("  source: \"adopt.scan-structure\"\n");
    yaml.push_str(&format!("  language: \"{}\"\n", language));

    if !frameworks.is_empty() {
        yaml.push_str("  frameworks:\n");
        for fw in &frameworks {
            yaml.push_str(&format!("    - \"{}\"\n", fw));
        }
    }

    yaml.push_str(&format!("  total_files: {}\n", files.len()));
    yaml.push_str("\nfiles:\n");

    for (path, category) in &files {
        yaml.push_str(&format!(
            "  - path: \"{}\"\n    description: \"{}\"\n",
            path, category
        ));
    }

    let output_path = Path::new(".process/skeleton.yaml");
    std::fs::write(output_path, &yaml).context("Failed to write skeleton.yaml")?;

    println!("{} Detected language: {}", "✔".green(), language.cyan());
    if !frameworks.is_empty() {
        println!(
            "{} Detected frameworks: {}",
            "✔".green(),
            frameworks.join(", ").cyan()
        );
    }
    println!(
        "{} Scanned {} files",
        "✔".green(),
        files.len().to_string().cyan()
    );
    println!(
        "{} Output saved to {}",
        "✔".green(),
        output_path.display()
    );

    Ok(())
}
